// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/*
 * All functions needed was implemented below, yet need to use the truffle-flattener tool to merge all
 * dependencies for then eliminate the unused functions, is possible, as example, approval functions, etc
 *
 * All function documentation yet no finished, do it ASAP!
 */

import "./node_modules/openzeppelin-solidity/contracts/token/ERC721/ERC721.sol";

contract SmartLand is ERC721 {
    //using Counters for Counters.Counter; // using the classical incrementation instead

    // event emited when an user is added (review)
    event UserRegistered(address _userAddress, uint256 _registryNo, uint256 _id, string _name);

    address private contractOwner;

    // auto-generate title Id numbers for the titles minted, starting from =0
    //Counters.Counter private titleId;
    uint256 private titleId;
    // auto-generate registry numbers for the users registered, starting from =0
    //Counters.Counter private registryNumber;
    uint256 private registryNumber;

    // Array with all title Ids generated for enumeration purposes:
    uint256[] allTitleIds;

    // struct variable holds all the title information for further mapping with titleId
    struct TitleInfo {
        string titleAddress; // physical address
        string titleCoordinates; // gps location
    }
     // Holds registeres users information for further mapping with address
    struct UserInfo {
        uint256 registryNo; // auto-generated by variable registryNumber
        uint256 id;
        string name;
    }

    // tracks the amount of title an address holds
    mapping(address => uint256) private _balances;
    // tracks the address owner of a given titleId
    mapping(uint256 => address) private _owners;
    // tracks the TitleInfo data of a given titleId
    mapping(uint256 => TitleInfo) _titleInfos;
    // return true if a given titleId exists
    mapping(uint256 => bool) _titleExists;
       // tracks the UserInfo data of a given user address
    mapping(address => UserInfo) userInfo;
    // return true if user has already registered on the system.
    mapping(address => bool) userExists;

    constructor () ERC721 ("SmartLand Token", "LAND") {
        contractOwner = msg.sender;
        registryNumber = 0;
        titleId = 0;

    }

    modifier onlyOwner() {
        require(msg.sender == contractOwner, "not the contract owner.");
        _;
    }

    /**
     * mint a nft title for a given address _receiver, and store the title information TitleInfo. 
     * 
     * requires:
     * - msg.sender should be contract owner;
     * - _receiver should be registered user.
     * return true if the nft is minted.
     */
    function mint(address _receiver, string memory _titleAddress, string memory _titleCoordinates)
            public onlyOwner returns (uint256 _titleId) {
        require(userExists[_receiver], "User receiver not registered");
        TitleInfo memory infos = TitleInfo(_titleAddress, _titleCoordinates);
        _mint(_receiver, titleId);
        _titleInfos[titleId] = infos;
        allTitleIds.push(titleId);
        _titleExists[titleId] = true;
        titleId++;
        return titleId -1;
    }

    /**
     * transfer nft titles between user addresses.
     *
     * requires:
     * - addresses _sender & _receiver should be registered.
     * return true if the transaction succeed.
     */
    function transfer(address _sender, address _receiver, uint256 _titleId) public returns (bool success) {
        require(userExists[_sender], "User sender not registered");
        require(userExists[_receiver], "User receiver not registered");
        _transfer(_sender, _receiver, _titleId);
        return true;
    }
    
    /**
     * getter function for the TitleInfo stored mapped from titleId to TitleInfo
     * return TitleInfo data.
     */
    function getTitleInfo(uint256 _titleId) public view returns (string memory, string memory) {
        TitleInfo memory infos = _titleInfos[_titleId];
        return (infos.titleAddress, infos.titleCoordinates);
    }
    
    /**
     * getter function for the address owner of a specific titleId.
     * return address of the owner.
     */
    function ownerOf(uint256 _titleId) public view override returns (address userOwner) {
            return _owners[_titleId];
    }
    
    /**
     * getter function for the amount of title owner by a given address.
     * return amount of titles owned
     */
    function balanceOf(address _address) public view override returns (uint256 balance) {
        return _balances[_address];
    }
    
    /**
     * returns totalBalance of all titles already minted.
     */
    function totalSupply() public view returns (uint256 totalBalance) {
        return allTitleIds.length;
    }

    /**
     * contract owner could transfer the ownership to another address.
     */
    function transferOwnership(address _newOwner) public onlyOwner returns (bool success) {
        contractOwner = _newOwner;
        return true;
    }

    /**
     * register an user to allow send/receive/hold titles.
     * inputs: a valid address, person's name and Id.
     * requires:
     * - msg.sender should be the contract owner;
     * - user address cannot be already registered.
     * return true if the registering succeed.
     */
    function registerUser(address _address, uint256 _id, string memory _name) 
            public onlyOwner returns (bool success) { //should add the keywork onlyOwner
        require(!(userExists[_address]), "User already registered"); // requires UserExists[_address] == false.
        userExists[_address] = true;
        uint256 _registryNo = registryNumber;
        UserInfo memory infos = UserInfo(_registryNo, _id, _name);
        userInfo[_address] = infos;
        emit UserRegistered(_address, _registryNo, _id, _name); // event should be reviewed
        registryNumber++;
        return true; 
    }

    /**
     * getter function for UserInfo search by user address;
     * return the UserInfo data 
     */
    function getUserInfo(address _address) public view returns (uint256, uint256, string memory) {
        require(userExists[_address], "User not registered");
        UserInfo memory infos = userInfo[_address];
        return (infos.registryNo, infos.id, infos.name);
    }

}